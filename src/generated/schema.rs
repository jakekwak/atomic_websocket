//
// This code was generated by a tool.
//
//
//   bebopc version:
//       3.0.14
//
//
//   bebopc source:
//       https://github.com/betwixt-labs/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[derive(Clone, Debug, PartialEq)]
pub struct Data<'raw> {
    pub category: u16,
    pub datas: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Data<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <u16>::MIN_SERIALIZED_SIZE + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.category.serialized_size() + self.datas.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.category._serialize_chained(dest)? +
            zelf.datas._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                category: v0,
                datas: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Data<'raw> {}

#[repr(u32)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Category {
    Ping = 10000,
    Pong = 10001,
    Expired = 10002,
    Disconnect = 10003,
    AppStartup = 10004,
    AppStartupOutput = 10005,
    SaveData = 10006,
    WindowAppConnectInfo = 10007,
    ValidClient = 10008,
    ClientId = 10009,
}

impl ::core::convert::TryFrom<u32> for Category {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u32) -> ::bebop::DeResult<Self> {
        match value {
            10000 => Ok(Category::Ping),
            10001 => Ok(Category::Pong),
            10002 => Ok(Category::Expired),
            10003 => Ok(Category::Disconnect),
            10004 => Ok(Category::AppStartup),
            10005 => Ok(Category::AppStartupOutput),
            10006 => Ok(Category::SaveData),
            10007 => Ok(Category::WindowAppConnectInfo),
            10008 => Ok(Category::ValidClient),
            10009 => Ok(Category::ClientId),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<Category> for u32 {
    fn from(value: Category) -> Self {
        match value {
            Category::Ping => 10000,
            Category::Pong => 10001,
            Category::Expired => 10002,
            Category::Disconnect => 10003,
            Category::AppStartup => 10004,
            Category::AppStartupOutput => 10005,
            Category::SaveData => 10006,
            Category::WindowAppConnectInfo => 10007,
            Category::ValidClient => 10008,
            Category::ClientId => 10009,
        }
    }
}

impl ::bebop::SubRecord<'_> for Category {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u32>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u32>()
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        u32::from(zelf)._serialize_chained(dest)
    });

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u32::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Category {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
}

#[derive(Clone, Debug, PartialEq)]
pub struct Ping<'raw> {
    pub peer: &'raw str,
    pub activations: i32,
}

impl<'raw> ::bebop::SubRecord<'raw> for Ping<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <&'raw str>::MIN_SERIALIZED_SIZE + <i32>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.peer.serialized_size() + self.activations.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.peer._serialize_chained(dest)? +
            zelf.activations._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                peer: v0,
                activations: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Ping<'raw> {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Pong {
    pub total_activations: i32,
}

impl ::bebop::FixedSized for Pong {}

impl<'raw> ::bebop::SubRecord<'raw> for Pong {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.total_activations)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                total_activations: v0,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Pong {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Expired {
    pub is_expired: bool,
}

impl ::bebop::FixedSized for Expired {}

impl<'raw> ::bebop::SubRecord<'raw> for Expired {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.is_expired)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { is_expired: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Expired {}

#[derive(Clone, Debug, PartialEq)]
pub struct Disconnect<'raw> {
    pub peer: &'raw str,
}

impl<'raw> ::bebop::SubRecord<'raw> for Disconnect<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.peer.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.peer._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { peer: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Disconnect<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct AppStartup<'raw> {
    pub id: &'raw str,
    pub app_type: u8,
}

impl<'raw> ::bebop::SubRecord<'raw> for AppStartup<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <&'raw str>::MIN_SERIALIZED_SIZE + <u8>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.id.serialized_size() + self.app_type.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.id._serialize_chained(dest)? +
            zelf.app_type._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                id: v0,
                app_type: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for AppStartup<'raw> {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct AppStartupOutput {
    pub success: bool,
}

impl ::bebop::FixedSized for AppStartupOutput {}

impl<'raw> ::bebop::SubRecord<'raw> for AppStartupOutput {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.success)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { success: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for AppStartupOutput {}

#[derive(Clone, Debug, PartialEq)]
pub struct SaveData<'raw> {
    pub save_key: u16,
    pub datas: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for SaveData<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <u16>::MIN_SERIALIZED_SIZE + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.save_key.serialized_size() + self.datas.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.save_key._serialize_chained(dest)? +
            zelf.datas._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                save_key: v0,
                datas: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for SaveData<'raw> {}

#[repr(u32)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum SaveKey {
    WindowAppConnectInfo = 1,
    ValidClient = 2,
    ClientId = 3,
}

impl ::core::convert::TryFrom<u32> for SaveKey {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u32) -> ::bebop::DeResult<Self> {
        match value {
            1 => Ok(SaveKey::WindowAppConnectInfo),
            2 => Ok(SaveKey::ValidClient),
            3 => Ok(SaveKey::ClientId),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<SaveKey> for u32 {
    fn from(value: SaveKey) -> Self {
        match value {
            SaveKey::WindowAppConnectInfo => 1,
            SaveKey::ValidClient => 2,
            SaveKey::ClientId => 3,
        }
    }
}

impl ::bebop::SubRecord<'_> for SaveKey {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u32>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u32>()
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        u32::from(zelf)._serialize_chained(dest)
    });

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u32::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for SaveKey {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
}

#[derive(Clone, Debug, PartialEq)]
pub struct WindowAppConnectInfo<'raw> {
    pub current_ip: &'raw str,
    pub broadcast_ip: &'raw str,
    pub gateway_ip: &'raw str,
    pub server_ip: &'raw str,
    pub port: &'raw str,
}

impl<'raw> ::bebop::SubRecord<'raw> for WindowAppConnectInfo<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.current_ip.serialized_size()
            + self.broadcast_ip.serialized_size()
            + self.gateway_ip.serialized_size()
            + self.server_ip.serialized_size()
            + self.port.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.current_ip._serialize_chained(dest)? +
            zelf.broadcast_ip._serialize_chained(dest)? +
            zelf.gateway_ip._serialize_chained(dest)? +
            zelf.server_ip._serialize_chained(dest)? +
            zelf.port._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                current_ip: v0,
                broadcast_ip: v1,
                gateway_ip: v2,
                server_ip: v3,
                port: v4,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for WindowAppConnectInfo<'raw> {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct ValidClient {
    pub is_valid: bool,
}

impl ::bebop::FixedSized for ValidClient {}

impl<'raw> ::bebop::SubRecord<'raw> for ValidClient {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.is_valid)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { is_valid: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for ValidClient {}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Data {
        pub category: u16,
        pub datas: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::Data<'raw>> for Data {
        fn from(value: super::Data) -> Self {
            Self {
                category: value.category,
                datas: value.datas.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Data {
        const MIN_SERIALIZED_SIZE: usize =
            <u16>::MIN_SERIALIZED_SIZE + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.category.serialized_size() + self.datas.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.category._serialize_chained(dest)? +
                zelf.datas._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    category: v0,
                    datas: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Data {}

    pub use super::Category;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Ping {
        pub peer: String,
        pub activations: i32,
    }

    impl<'raw> ::core::convert::From<super::Ping<'raw>> for Ping {
        fn from(value: super::Ping) -> Self {
            Self {
                peer: value.peer.into(),
                activations: value.activations,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Ping {
        const MIN_SERIALIZED_SIZE: usize =
            <String>::MIN_SERIALIZED_SIZE + <i32>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.peer.serialized_size() + self.activations.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.peer._serialize_chained(dest)? +
                zelf.activations._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    peer: v0,
                    activations: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Ping {}

    pub use super::Pong;

    pub use super::Expired;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Disconnect {
        pub peer: String,
    }

    impl<'raw> ::core::convert::From<super::Disconnect<'raw>> for Disconnect {
        fn from(value: super::Disconnect) -> Self {
            Self {
                peer: value.peer.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Disconnect {
        const MIN_SERIALIZED_SIZE: usize = <String>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.peer.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.peer._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self { peer: v0 }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Disconnect {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct AppStartup {
        pub id: String,
        pub app_type: u8,
    }

    impl<'raw> ::core::convert::From<super::AppStartup<'raw>> for AppStartup {
        fn from(value: super::AppStartup) -> Self {
            Self {
                id: value.id.into(),
                app_type: value.app_type,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for AppStartup {
        const MIN_SERIALIZED_SIZE: usize =
            <String>::MIN_SERIALIZED_SIZE + <u8>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.id.serialized_size() + self.app_type.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.id._serialize_chained(dest)? +
                zelf.app_type._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    id: v0,
                    app_type: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for AppStartup {}

    pub use super::AppStartupOutput;

    #[derive(Clone, Debug, PartialEq)]
    pub struct SaveData {
        pub save_key: u16,
        pub datas: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::SaveData<'raw>> for SaveData {
        fn from(value: super::SaveData) -> Self {
            Self {
                save_key: value.save_key,
                datas: value.datas.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for SaveData {
        const MIN_SERIALIZED_SIZE: usize =
            <u16>::MIN_SERIALIZED_SIZE + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.save_key.serialized_size() + self.datas.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.save_key._serialize_chained(dest)? +
                zelf.datas._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    save_key: v0,
                    datas: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for SaveData {}

    pub use super::SaveKey;

    #[derive(Clone, Debug, PartialEq)]
    pub struct WindowAppConnectInfo {
        pub current_ip: String,
        pub broadcast_ip: String,
        pub gateway_ip: String,
        pub server_ip: String,
        pub port: String,
    }

    impl<'raw> ::core::convert::From<super::WindowAppConnectInfo<'raw>> for WindowAppConnectInfo {
        fn from(value: super::WindowAppConnectInfo) -> Self {
            Self {
                current_ip: value.current_ip.into(),
                broadcast_ip: value.broadcast_ip.into(),
                gateway_ip: value.gateway_ip.into(),
                server_ip: value.server_ip.into(),
                port: value.port.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for WindowAppConnectInfo {
        const MIN_SERIALIZED_SIZE: usize = <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.current_ip.serialized_size()
                + self.broadcast_ip.serialized_size()
                + self.gateway_ip.serialized_size()
                + self.server_ip.serialized_size()
                + self.port.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.current_ip._serialize_chained(dest)? +
                zelf.broadcast_ip._serialize_chained(dest)? +
                zelf.gateway_ip._serialize_chained(dest)? +
                zelf.server_ip._serialize_chained(dest)? +
                zelf.port._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    current_ip: v0,
                    broadcast_ip: v1,
                    gateway_ip: v2,
                    server_ip: v3,
                    port: v4,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for WindowAppConnectInfo {}

    pub use super::ValidClient;
}
